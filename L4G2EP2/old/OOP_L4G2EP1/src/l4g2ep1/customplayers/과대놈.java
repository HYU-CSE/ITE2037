package l4g2ep1.customplayers;

import l4g2ep1.*;
import l4g2ep1.common.*;

/**
 * 여러분이 새로운 플레이어를 만들기 위해 실제로 작성하게 될 클래스입니다.
 * 
 * @author Racin
 * 
 */
public class 과대놈 extends Player {
	
	DirectionCode[] shuffledDirections;
	int[] shuffledDirection_values;
	
	void ShuffleDirections()
	{
		//초기화에 필요한 임의의 자연수 하나 생성
		int seed = myInfo.GetID();
		seed *= seed;
		seed = gameInfo.GetGameNumber() - seed;
		seed *= seed;
		
		if ( seed <= 0 )
			seed += Integer.MAX_VALUE;
		
		/*
		 * 네 가지 방향을 나열할 수 있는 방법은 총 4 * 3 * 2 * 1 = 24가지 존재하므로
		 * seed를 24로 나눈 나머지를 토대로 방향 설정.
		 * (24가지면 그냥 switch문 쓰는게 더 쉽고 빠르겠지만 코드가 길어지니 직접 계산)
		 */
		//각 자리에서 '값이 증가'해야 하는 정도를 먼저 측정. seed를 24로 나눈 나머지가 0인 경우 0000, 23인 경우 3210이 됨.
		int[] offsets = new int[4];
		
		offsets[0] = seed % 24 / 6;
		offsets[1] = seed % 6 / 2;
		offsets[2] = seed % 2;
		offsets[3] = 0;

		//위에서 측정한 offset을 통해 각 자리의 값을 계산.
		//모든 계산이 끝나면 offset이 0000이었을 때 값은 0123이 됨 (유일하게 offset이 3210이었을 때만 그 배열 그대로 값이 됨)
		shuffledDirection_values = new int[4];

		for ( int iCurrent = 0; iCurrent < 4; ++iCurrent )
		{
			int current_value = 0;
			
			while ( true )
			{
				//현재 자리보다 앞에 이미 같은 값이 있는지 검사 
				boolean isSameValueFound = false;
				
				for ( int iPrevious = iCurrent - 1; iPrevious >= 0; --iPrevious )
					if ( shuffledDirection_values[iPrevious] == current_value )
					{
						isSameValueFound = true;
						break;
					}
				
				//같은 값이 있는 경우 현재 자리의 값을 1 증가시키고 다시 검사
				if ( isSameValueFound == true )
				{
					++current_value;
				}
				//같은 값이 없고 현재 자리의 offset이 0이 아닌 경우(여기서 값을 증가시켜야 하는 경우)
				//offset을 1 깎은 다음 현재 자리의 값을 1 증가시키고 다시 검사 
				else if ( offsets[iCurrent] != 0 )
				{
					--offsets[iCurrent];
					++current_value;
				}
				//같은 값도 없고 offset도 0인 경우 값 계산 완료
				else
				{
					break;
				}
			}
			
			//계산이 끝난 현재 자리의 값을 기록
			shuffledDirection_values[iCurrent] = current_value;
		}
				
		//0: Up, 1: Left, 2: Right, 3: Down으로 간주하여 각 자리의 값을 토대로 실제 방향 설정 
		shuffledDirections = new DirectionCode[4];
		
		for ( int i = 0; i < 4; ++i )
			switch ( shuffledDirection_values[i] )
			{
			case 0:
				shuffledDirections[i] = DirectionCode.Up;
				break;
			case 1:
				shuffledDirections[i] = DirectionCode.Left;
				break;
			case 2:
				shuffledDirections[i] = DirectionCode.Right;
				break;
			default:
				shuffledDirections[i] = DirectionCode.Down;
				break;
			}
	}


	public 과대놈() {
		name = "과대놈"; // TODO 자신이 만들 플레이어의 이름으로 name 필드를 초기화하세요.
		acceptDirectInfection = false;
		receiveOthersInfo_detected = true;
		
		// TODO '직접 감염'을 받으려는 경우 이 필드를 true로 두고
										// 아닌 경우 false로 두세요.
	}

	@Override
	public DirectionCode Survivor_Move() {
			 /* 정찰병의 생존자 이동: 생존자 수 x 시체와 감염체 수가 가장 큰 방향을 선택
			 */
			
			//방향별로 각 플레이어 수 및 포착 기대값을 기록하기 위한 배열 사용
			//0: Up, 1: Left, 2: Right, 3: Down
			int[] survivors = new int[4];
			int[] others = new int[4];
			int[] weights = new int[4];
			int max_weight = -1;
			
			//현재 포착된 모든 플레이어에 대해 검사 수행
			for ( PlayerInfo other : othersInfo_detected )
			{
				//해당 플레이어와 나 사이의 거리 비교
				Vector v = GetDistanceVectorBetweenPlayers(other);

				//해당 플레이어의 현재 상태에 따라 플레이어 수 기록
				if ( other.GetState() == PlayerInfo.State.Survivor )
				{
					if ( v.y_offset < 0 )
						++survivors[0];
		
					if ( v.x_offset < 0 )
						++survivors[1];
					
					if ( v.x_offset > 0 )
						++survivors[2];
					
					if ( v.y_offset > 0 )
						++survivors[3];
				}
				else
				{
					if ( v.y_offset < 0 )
						++others[0];
		
					if ( v.x_offset < 0 )
						++others[1];
					
					if ( v.x_offset > 0 )
						++others[2];
					
					if ( v.y_offset > 0 )
						++others[3];
				}
			}

			//포착 기대값: 생존자 수 x 시체 및 감염체 수 계산
			for ( int i = 0; i < 4; ++i )
				weights[i] = survivors[i] * others[i];
			
			//갈 수 없는 방향에 대해 기대값을 최소값으로 설정
			if ( IsValidMove(DirectionCode.Up) == false )
				weights[0] = -1;
			
			if ( IsValidMove(DirectionCode.Left) == false )
				weights[1] = -1;

			if ( IsValidMove(DirectionCode.Right) == false )
				weights[2] = -1;

			if ( IsValidMove(DirectionCode.Down) == false )
				weights[3] = -1;

			//측정된 기대값의 최대값이 몇인지 계산
			for ( int weight : weights )
				if ( weight > max_weight )
					max_weight = weight;
			
			//'방향 섞기' 설정에 따라 기대값이 최대값과 같은 방향들 중 하나 선택 - 최소 하나 존재
			for ( int iShuffledDirection = 0; iShuffledDirection < 4; ++iShuffledDirection )
				if ( weights[ shuffledDirection_values[iShuffledDirection] ] == max_weight )
					return shuffledDirections[iShuffledDirection];

			//여기까지 코드가 실행될 가능성은 없지만 컴파일 오류를 막기 위해 return 한 줄 추가
			return DirectionCode.Stay;
		}
		// TODO 생존자 상태일 때 이동하기 위한 생각을 여기에 담으세요.
	
	@Override
	public void Corpse_Stay()
	{
	
		// TODO 시체 상태일 때 현재 알고 있는 것을 바탕으로 생각을 진행하려면 여기에 담으세요.
	}

	int MS;// 가는 0 도는 1
	DirectionCode[][] DC;// 돌면서 가는 코드
	int i;

	@Override
	public DirectionCode Infected_Move() {
		Point ME = myInfo.GetPosition();
		int x, y;

		if (MS == 0) {
			if (ME.x >= 4 && ME.y < 4) {
				x = 7 - ME.x;
				y = 1 - ME.y;

				if (x < 0) {

					x *= (-1);
				}

				if (y < 0) {

					y *= (-1);
				}

				if (x >= y) { // 이게 가로로 가는거임

					if (ME.x > 7) {

						return DirectionCode.Left;
					}

					if (ME.x < 7) {

						return DirectionCode.Right;
					}

					MS = 1;
					i = 0;

				}

				if (x < y) {// 이건 세로로 갈거임

					if (ME.y > 1) {

						return DirectionCode.Up;
					}

					if (ME.y < 1) {

						return DirectionCode.Down;
					}

				}
			}// 1사분면일때

			if (ME.x < 4 && ME.y < 4) {
				x = 1 - ME.x;
				y = 1 - ME.y;

				if (x < 0) {

					x *= (-1);
				}

				if (y < 0) {

					y *= (-1);
				}
				
				if (x >= y) { // 이게 가로로 가는거임

					if (ME.x > 1) {

						return DirectionCode.Left;
					}

					if (ME.x < 1) {

						return DirectionCode.Right;
					}

					MS = 1;
					i = 0;

				}

				if (x < y) {// 이건 세로로 갈거임

					if (ME.y > 1) {

						return DirectionCode.Up;
					}

					if (ME.y < 1) {

						return DirectionCode.Down;
					}

				}

			}// 2사분면

			if (ME.x < 4 && ME.y >= 4) {
				x = 1 - ME.x;
				y = 7 - ME.y;

				if (x < 0) {

					x *= (-1);
				}

				if (y < 0) {

					y *= (-1);
				}
				
				if (x >= y) { // 이게 가로로 가는거임

					if (ME.x > 1) {

						return DirectionCode.Left;
					}

					if (ME.x < 7) {

						return DirectionCode.Right;
					}

					MS = 1;
					i = 0;

				}

				if (x < y) {// 이건 세로로 갈거임

					if (ME.y > 1) {

						return DirectionCode.Up;
					}

					if (ME.y < 1) {

						return DirectionCode.Down;
					}

				}
				
				if (x >= y) { // 이게 가로로 가는거임

					if (ME.x > 7) {

						return DirectionCode.Left;
					}

					if (ME.x < 7) {

						return DirectionCode.Right;
					}

					MS = 1;
					i = 0;

				}

				if (x < y) {// 이건 세로로 갈거임

					if (ME.y > 7) {

						return DirectionCode.Up;
					}

					if (ME.y < 7) {

						return DirectionCode.Down;
					}

				}
			}// 3

			if (ME.x >= 4 && ME.y >= 4) {
				x = 7 - ME.x;
				y = 7 - ME.y;

				if (x < 0) {

					x *= (-1);
				}

				if (y < 0) {

					y *= (-1);
				}
				
				if (x >= y) { // 이게 가로로 가는거임

					if (ME.x > 7) {

						return DirectionCode.Left;
					}

					if (ME.x < 7) {

						return DirectionCode.Right;
					}

					MS = 1;
					i = 0;

				}

				if (x < y) {// 이건 세로로 갈거임

					if (ME.y > 7) {

						return DirectionCode.Up;
					}

					if (ME.y < 7) {

						return DirectionCode.Down;
					}
				}
			}// 4
			

		}

		if(MS==1){
			
			if (ME.x >= 4 && ME.y < 4){
				
				DirectionCode Use = DC[0][i];

				i++;
				i %= 8;
				
				return Use;
			}
			if (ME.x < 4 && ME.y < 4){
				
				DirectionCode Use = DC[1][i];

				i++;
				i %= 8;
				
				return Use;
			}
			if (ME.x < 4 && ME.y >= 4){
				
				DirectionCode Use = DC[2][i];

				i++;
				i %= 8;
				
				return Use;
			}
			if (ME.x >= 4 && ME.y >= 4){
				
				DirectionCode Use = DC[3][i];

				i++;
				i %= 8;
				
				return Use;
			}
			
		}
		// TODO 감염체 상태일 때 이동 또는 대기하기 위한 생각을 여기에 담으세요.
		return null;
	}

	@Override
	public void Soul_Stay() {
		if (gameInfo.GetCurrentTurnNumber() == 0) {
			spawn = new Point[4];
			spawn[0] = new Point(3, 3);
			spawn[1] = new Point(3, 5);
			spawn[2] = new Point(5, 5);
			spawn[3] = new Point(5, 3);
			
			DC = new DirectionCode[4][8];
			
			DC[0][0] = DirectionCode.Right;
			DC[0][1] = DirectionCode.Up;
			DC[0][2] = DirectionCode.Left;
			DC[0][3] = DirectionCode.Down;
			DC[0][4] = DirectionCode.Down;
			DC[0][5] = DirectionCode.Left;
			DC[0][6] = DirectionCode.Up;
			DC[0][7] = DirectionCode.Right;
			
			DC[1][0] = DirectionCode.Up;
			DC[1][1] = DirectionCode.Left;
			DC[1][2] = DirectionCode.Down;
			DC[1][3] = DirectionCode.Right;
			DC[1][4] = DirectionCode.Right;
			DC[1][5] = DirectionCode.Down;
			DC[1][6] = DirectionCode.Left;
			DC[1][7] = DirectionCode.Up;
			
			DC[2][0] = DirectionCode.Down;
			DC[2][1] = DirectionCode.Left;
			DC[2][2] = DirectionCode.Up;
			DC[2][3] = DirectionCode.Right;
			DC[2][4] = DirectionCode.Right;
			DC[2][5] = DirectionCode.Up;
			DC[2][6] = DirectionCode.Left;
			DC[2][7] = DirectionCode.Down;

			DC[3][0] = DirectionCode.Down;
			DC[3][1] = DirectionCode.Right;
			DC[3][2] = DirectionCode.Up;
			DC[3][3] = DirectionCode.Left;
			DC[3][4] = DirectionCode.Left;
			DC[3][5] = DirectionCode.Up;
			DC[3][6] = DirectionCode.Right;
			DC[3][7] = DirectionCode.Down;
			
			ShuffleDirections();
			// TODO 직접 만든 데이터 필드에 대한 초기화 코드를 여기에 적으세요. 이 메서드는 게임이 시작되면 가장 먼저
			// 호출됩니다.
			
		}

		// TODO 영혼 상태일 때 현재 알고 있는 것을 바탕으로 생각을 진행하려면 여기에 담으세요.
	}

	Point[] spawn;
	int next;

	@Override
	public Point Soul_Spawn() {
		Point Use = spawn[next];

		next++;
		next %= 4;

		MS = 0;
		return Use; // TODO 영혼 상태일 때 재배치하기 위한 생각을 여기에 담으세요.
	}

}
